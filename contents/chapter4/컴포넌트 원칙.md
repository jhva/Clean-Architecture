# 컴포넌트 원칙 

_SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다._

- [_컴포넌트_](#컴포넌트)
- [_컴포넌트 응집도_](#컴포넌트-응집도)
- [_컴포넌트 결합_](#컴포넌트-결합)



##  컴포넌트
- 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다 .
- 컴포넌트는 배포 단위이며, 모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자다.
- 잘 설계된 컴폰넌트는 독립적으로 배포가 가능 해야한다.

### 컴포넌트의 간략한 역사 
- 옛날에는 메모리를 어느 위치에 로드할지 항상 고민 거리였음.
    1. 오늘날에는 메모리를 어느 위치에 로드할지 고민할 필요가없다.
    2. 한번 위치가 결정되면 재배치가 불가능했다.
    3. 라이브러리 같은 경우는 소스코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일 하였다.
    4. 하지만 장치는 너무느리고 메모리는 너무 비싸서 자원이 한정적이었기에, 이러한 접근법은 문제가 있었다. 

![스크린샷 2023-10-24 오전 10.16.40.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-24%20%EC%98%A4%EC%A0%84%2010.16.40.png)
- 위에서 언급한 접근법에 대한 문제가 계속해서 발생됨에따라, 그 시대 프로그래머는 컴파일 시간을 단축시키기 위해 함수 라이브러리를 개별적으로 분리했다.
- 심벌 테이블을 통해 컴파일된 바이너리를 특정위치에 로드하였고, 그 이후 애플리케이션을 로드했다.
- _하지만 이러한 방식도 처음엔 잘 동작했지만, 애플리케이션은 점점 커져가며 결국 할당된 공간을 넘어서게되면서 애플리케이션을 두 개의 주소 세그먼트로 분리해서 함수 라이브러리 공간을 사이에 오가며 동작하게 배치하였다._
    1. 여담으로 과거 대다수의 머신은 컴퓨터의 전원이 꺼지더라도 데이터가 삭제되지 않는 코어 메모리를 사용하였다고한다. 함수 라이브러리를 한번 로드되면 며칠 동안 그대로 두었다.
    2. 하지만 이 방식도 오래가지 못하였으며 라이브러리나 프로그램이 메모리 사용율이 올라갈수록 이와 같은 단편화가 지속적으로 이어졌다.


### 재배치성 
- 단편화 문제를 해결하기위해 메모리에 재배치 할수 있는 형태의 바이너리를 생성하도록 컴파일러 수정을 통해 해결하였다.
- 재배치를 하게되면 로더가 위치 정보를 전달받아, 재배치 가능한지 플래그를 통해 삽입여부를 정하였다.
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정하였다.
    1. 프로그램을 통해 라이브러리 함수를 호출하면 함수이름을 `외부 참조`로 생성하였다. 
    2. 라이브러리 함수를 정의하는 프로그램이면 `외부 정의`로 생성하였다.
    3. 이 부분을 통해 `링킹 로더` 가 탄생하였다.

### 링커 
- 링킹 로더로 인해 프로그램을 개별적으로 컴파일하고 로드 할 수 있는 단위로 분할 할 수 있게 되었다.
- 하지만 링킹 로더는 느린 장치를 이용해서 수십에서 수백 개의 바이너리 라이브러리를 읽고 외부 참조를 해석하고있었기때문에 프로그램 하나 로드하는데에만 1시간 이상이 걸렸으며 이를 해결하기위해 `로드`와 
  `링크`를 두 단계로 분리하였다 .
  1. 프로그램 느린부분을 `링커`라는 별도의 애플리케이션으로 작업을 처리하였다.
  2. 링커는 링크가 완료된 재배치 코드를 만들어 로더의 로딩 과정을 빠르게 해주었다. 
- 이후 `무어`가 등장하여 컴퓨터 하드웨어 측면으로부터 모든 점이 급격하게 좋아졌다.
  1. 이를 통해 링크 시간이 줄어들었다.
  2. 많은 경우 링크 시간은 초단위 수준이 될 정도로 감소하였다. 
  3. 이렇게 오늘날에 .jar , DLL,공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것이 일상이 되었다.


### 결론 
_런타임에 플러그인 형태로 결합 할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당된다._




## 컴포넌트 응집도 
_컴포넌트 응집도와 관련된 세 가지 원칙 `REF:재사용/릴리스 등가 원칙`, `CCP: 공통 폐쇄 원칙`,`CRP: 공통 재사용 원칙` 등 을 논의한다._



### REF: 재사용/릴리스 등가 원칙
- 재사용 단위는 릴리스 단위와 같다. 
- 뒤죽박죽 임의로 선택된 클래스와 모듈로 구성되어서는 안된다.
- 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 한다.
- 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

### CCP: 공통 폐쇄 원칙 
- 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다.
- 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
- 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
    1. 이를 통해 소프트웨어 릴리스,재검증,배포하는 일과 관련된 작업량을 최소화할 수 있다.

#### SPR 와의 유사성 
- CCP는 컴포넌트 수준의 SRP 이다. 
- 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어야한다.
- 서로 다른 시점에 다른 이유로 변경되는 것들을 서로 분리해야한다. 


### CRP: 공통 재사용 원칙
- 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다. 
  1. 재사용 가능한 모듈은 다른 클래스와 상호작용 하는 경우가 많다.
- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다. 
  1. 그렇지 않으면 필요 이상으로 많은 컴포넌트를 재배포할 가능성이 높다. 
- _CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다._

#### ISP와의 관계
_필요하지 않은 것에 의존하지 말라_


### 컴포넌트 응집도에 대한 균형 다이어그램 
- REP와 CCP는 `포함 원칙`이다. 
- CRP 는 `배제 원칙` 이다. 

![스크린샷 2023-10-24 오전 11.10.24.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-24%20%EC%98%A4%EC%A0%84%2011.10.24.png)
- 오로지 REP 와 CRP 에 중점을 두면 변경이 생길때 너무 많은 컴포넌트에 영향을 미친다. 
- 프로젝트 초기에는 CCP 가 REP 보다 훨씬 중요하다
  1. 개발 가능성보다 재사용성을 중요하게 생각하기 때문이다.
- 일반적으로 프로젝트는 CCP로 부터 시작하며 프로젝트는 삼각형에서 점차 왼쪽으로 향한다. 

### 결론 
- 어느 클래스들을 상충하는 힘을 반드시 고려해야 한다. 
- 애플리케이션의 요구에 맞게 균형을 잡는 일이 중요하다. 
- 균형점은 항상 유동적이다. 
- 프로젝트는 시간이 흐름에 따라 구성하는 방식들이 진화한다. 


## 컴포넌트 결합
_개발 가능성과 논리적 설계 사이의 균형을 다루기 위해 세 가지 원칙을 설명한다_

### ADP: 의존성 비순환 원칙 
_컴포넌트 의존성 그래프에 순환이 있어서는 안 된다_
- 대규모 프로젝트를 갈 수록 여러 개발자가 많이 투입하게 되는데, 이때 동일한 소스파일을 수정해야 되는 일이 발생하게된다. 
  1. 많은 개발자가 투입됨으로써 누군가 마지막으로 수정한 코드로 인해 반복작업이 계속해서 이어진다. 
  2. 이러한 문제를 해결하기 위해 `주 단위 빌드`,`의존성 비순환 원칙`이 생겼다. 

#### 주 단위 빌드 
- 주 단위 빌드는 중간 규모의 프로젝트에서 흔하게 사용된다. 
- 일주일의 첫 4일은 서로 신경 쓰지 않고 개발한다. 이후 금요일이 될 때 변경된 코드를 모두 통합해서 시스템에 빌드한다.
  1. 하지만 프로젝트 규모가 커지게되면 통합하는 부분은 서서히 시간이 길어지며 팀의 효율성이 나빠진다. 
  2. 이를 해결하기 위해 `순한 의존성 제거`가 나왔다. 
#### 비 순환 원칙 
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리한다. 
  1. 이를 통해 각 담당 개발자 들은 책임질 수 있는 작업 단위가 된다. 
      - 개발자가 해당 컴포넌트를 동작하게 만든다 
      - 해당 컴포넌트를 릴리스해서 다른 개발자가 사용할 수 있도록 만든다. 
      - 담당 개발자자는 릴리스 번호를 부여한다. 
      - 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다. 
      - 이후 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 
- 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다. 

#### 순환이 컴포넌트 의존성 그래프에 미치는 영향
![스크린샷 2023-10-24 오전 11.30.48.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-24%20%EC%98%A4%EC%A0%84%2011.30.48.png)
- 위 사진에서 Database 컴포넌트를 릴리스하게되면 `Entities`컴포넌트와 반드시 호환되어 있어야하고.
- 하지만 `Entities`를 컴포넌트는 `Authorizer`와 순환이 되므로 Database 컴포넌트는 `Authorizer`와도 호환이 되어야한다. 또 `Authorizer`는 
  `Interactors`에 의존하게 된다. 
  1. 이러한 결과로인해 자신의 작업물들이 언제 통합할지 반드시 결정해야한다. 

- 이처럼 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.
- 단위 테스트를 하고 릴리스를 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다.
- 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다. 

#### 순환 끊기 
![스크린샷 2023-10-24 오전 11.42.36.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-24%20%EC%98%A4%EC%A0%84%2011.42.36.png)

- `Entites`와 `Authorizer`가 모두 의존하는 새로운 컴포넌트를 만들어 `의존성 역전 원칙`을 적용한다.

#### 흐트러짐 (Jitters) 
- 의존성 구조는 서서히 흐트러지며 성장하고 항상 관찰해야 한다. 
- `순환이 발생하게되면 어떤 식으로든 끊어 내어,새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질수도 있음을 의미함.`

### SDP:안정된 의존성 원칙
_안전성의 방향으로 의존하라_
- 공통 폐쇄 원칙을 준수하게 하고, 컴포넌트가 다른 유형의 변경에 영향받지 않도록한다.
- 컴포넌트 중 일부는 변동성을 지닐수있도록 설계한다.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
  1. 한번 의존하게 되면 큰 컴포넌트도 결국 변경이 어렵다. 
- 안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안전성 
- 컴포넌트 안쪽으로 들어오는 의존성이 많아지게 되면 상당히 안정적이다. 
  1. 상소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 든다. 

![스크린샷 2023-10-24 오전 11.58.49.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-24%20%EC%98%A4%EC%A0%84%2011.58.49.png)
- 위 사진 처럼 세 컴포넌트가 X에 의존하고 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다 
  1. 따라서 이와 같은 경우를 `독립적이다` 라고 얘기하고 위와 같은 설계가 안정된 컴포넌트라 말한다
  2. 하지만 반대로  X를 의존하지 않고 X가 세 개의 컴포넌트를 의존할 경우 세 개의 컴포넌트는 변경이 발생할 수 있는 외부 요인이 많아지게 됨으로 이는 불안정한 컴포넌트라 말한다. 

#### 안정성 지표 
- Fan-in
  1. 안으로 들어오는 의존성이며, 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타냄 
- Fan-out
  1. 바깥으로 나가는 의존성이며 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타냄
- I 불안정성 
  1. I= Fan-out / (Fan-in+Fan-out) [0,1]
  2. [0,1] 범위를 갖으며 I=0일때 최고로 안정된 컴포넌트라고한다. 
  3. I는 1일때 최고로 불안정한 컴포넌트라 한다 .

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다
- SDP를 위배하는 일이 생겼을 경우엔 DIP를 도입하여 문제를 해결한다. 
  1. 인터페이스를 생성하여 의존에 문제되는 컴포넌트를 넣는다. 
  2. 인터페이스에 모든 메서드가 반드시 선언 되어야한다. 
#### 추상 컴포넌트 
- 추상 컴포넌트는 상당히 안정적이며, 덜 안정적인 컴포넌트가 의존시 이상적인 대상이 된다. 

### SAP: 안정된 추상화 원칙 
_컴포넌트는 안정된 정도만큼만 추상화 되어야 한다._


#### 고수준 정책을 어디에 위치시켜야 하는가 ? 
- 불안정한 컴포넌트는 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.
- 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야한다. 
  1. 고수준 정책을 안정된 컴포넌트 위에 위치하면 소스 코드를 수정하기 어려워지는데 이때 변경되는 부분을 대응할 수 있을 정도로 유연하게 만들려면 `개방 폐쇄 원칙`을 통해 찾을 수 있으며, `추상  클래스`로 이 원칙을 준수할 수 있다.


### 안정된 추상화 원칙 
- 안정된 컴포넌트는 추상 컴포넌트여야 한다. 
  1. 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다 
- 안정적인 컴포넌트라면 인터페이스와 추상 클래스로 구성 되어 쉽게 확장할 수 있어야 한다. 
  1. 이를 통해 유연성을 얻으며, 아키텍처를 과도하게 제약하지 않게 된다. 
- _**SDP는 의존성이 반드시 안정성 방향으로 향하며 SAP는 안정성이 결국 추상화를 의미한다고 말한다.** _
  1. _의존성은 추상화의 방향으로 향하게 된다._

#### 추상화 정도 측정 
- Nc 
  1. 컴포넌트의 클래스 개수 
- Na
  1. 컴포넌트의 추상 클래스와 인터페이스의 개수 
- A
  1. A= NA / NC  추상화 정도 
- 계산을 통해 A지표는 0 과 1사이의 값을 얻게된다. 이를 통해 추상클래스가 포함이 되었는지 포함하는지를 알 수 있다.


### 결론 
책에서 나온 부분을 정확하게 다 쓰진 않았다 `추상화 정도 측정` 이후로는 `주계열`을 기준으로 `쓸모없는 구역` `고통의 구역`으로 나뉘면서 각 구역에 대해 설명하고 어떻게 해야 벗어나는지 주계열과의 거리를 
통해 의존하는 컴포넌트를 알 수 있었다. <br/>

하지만 현재 나에게는 측정을 통해 얼마만큼의 수준에서 잘 부합하는지를 지표를 통해 계산하는 방법은 필요가 없는 것 같다. 그 이유는 아직 이정도 수준만큼의 의존성이 결합되어 문제가 발생되어 엉켜있는 의존성을 
풀어나아가는 경험을 한번도 경험해보지 못하였기때문이다. 앞으로의 많은 프로젝트 등을 해보면서 직접 경험하고 다시 한번 읽어보면 되게 좋을 것 같다. 


_책에서 말하는 결론은 지표는 측정값에 지나지 않으며 지표는 아무리해도 불완전 하다. 하지만 지표는 어떤 유용한 무언가를 찾을 때 사용하기를 바라고있다_.