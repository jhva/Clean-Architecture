# 설계 원칙 
_좋은 소프트웨어 시스템은 깔끔한 코드로 부터 시작 되며 좋은 아키텍처로 부터 정의하는 원칙이 SOLID 원칙이다_ 



- [_SRP 단일 책임 원칙_](#단일-책임-원칙)
  1. 소프트웨어 모듈의 변경은 단 하나의 이유가 있어야한다.
- [_OCP 개방 폐쇄 원칙_](#개방-폐쇄-원칙)
  1. 새로운 코드를 추가할때 기존의 코드를 수정하지 않고 쉽게 추가 할 수 있어야한다.
- [_LSP 리스코프 치환 원칙_](#리스코프-치환-원칙)
  1. 자식 객체에서 부모 객체를 완전히 대체할 수 있어야한다.
- [_ISP 인터페이스 분리 원칙_](#인터페이스-분리-원칙)
    1. 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않는다.
- [_DIP 의존성 역전 원칙_](#의존성-역전-원칙)
    1. 고수준 코드는 저수준 코드에 절대 의존해서는 안된다. 전



## 단일 책임 원칙 
- 함수는 단, 하나의 일만 해야 한다.
- 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.
- 단일 모듈은 변경의 이유가 오직 하나여야만 한다.
- 함수와 데이터 구조로 구성된 코드를 묶어주는 힘이 바로 `응집성` 이다.
- 아래에서 원칙을 위반하는 사례를 함께보자
### 원칙을 위반하는 사례 1 - 우발적 중복 
![스크린샷 2023-10-23 오전 10.53.11.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%EC%A0%84%2010.53.11.png)

- 사진 속에 있는 Employee 클래스는 `SRP 즉, 단일 책임 원칙` 을 위반한다고 한다.
  1. calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용 된다.
  2. reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며 COO 보고를 위해 사용한다.
  3. save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용된다,


![스크린샷 2023-10-23 오전 11.07.32.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%EC%A0%84%2011.07.32.png)
- 위 그림은 코드 중복을 피하기 위해 reqularHours()라는 메서드에 넣었다고 가정해보는 사례이다. 
- 각 메서드는 부서마다 특정 기능을 수행하기 위한 메서드 들이지만 이렇게 되면 비지니스 로직에서 또한 불상사를 초래할 수 있으며 이러한 문제를 해결하기 위해 `서로 다른 역할을 수행하며 의존하는 코드들은 서로 분리 해야한다`. 

### 원칙을 위반하는 사례 2 - 병합 
- 소스 파일에 다양하고 많은 메서드가 포함되면 병합이 자주 발생된다. 
- 메서드들은 서로 다른 역할을 책임 진다면 병합이 발생할 가능성은 높다. 
  1. 위에서 언급된 메서드들을 각기 다른 개발자가 변경하고 적용하게되면 결과적으로 병합이 발생한다. 
  2. 현시대 도구들은 굉장히 뛰어나지만, 어떤 도구도 병합이 발생하는 모든 경우의 수를 해결 할 수 없고 병합에는 항상 위험이 따르게된다. 
- 문제를 해결하기위해선 `코드를 뒷받침하는 것을 서로 분리하는 것이다.`


### 해결책 
- 메서드를 각기 다른 클래스로 이동시키는 방법 
- 클래스들은 서로 몰라야하며, 이를 통해 `우연한 중복`을 피할 수 있다.
- 가장 중요한 클래스는 기존 클래스에 두나, 덜 중요한 메서드들은 따로 뺴는 방식을 선호한다.

### 결론 
- 단일 책임 원칙은 `메서드와 클래스 수준의 원칙이다`
- 컴포넌트 수준에서는 `공통 폐쇄 원칙` 이 된다. 
- 아키텍처 수준에서는 `아키텍처 경계`의 생성을 책임지는 병경의 축 이된다. 



## 개방 폐쇄 원칙 
_객체에 확장에는 항시 열려있어야 하고, 변경에는 닫혀 있어야 한다. 즉 소프트웨어 개체의 행위는 확장할 수 있어야하지만 이때 객체를 변경해서는 안 된다._
- **요구사항을 변경하는데 있어 소프트웨어를 엄청나게 많이 수정해야 한다면 그 설계한 아키텍처는 엄청난 실패에 맞닥뜨린다.**
- 대다수 사람들은 OCP를 클래스와 모듈을 설꼐할 때 도움되는 원칙이라고 하는데, 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다. `사고실험` 을 통해 알아보자 

## 사고실험 
- 소프트웨어의 이상적인 변경량은 0이다.
- 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다. 
- 이러한 목적을 달성하기 위해선 클래스 단위로 분할하고 컴포넌트 단위로 구분해야한다. 
![스크린샷 2023-10-23 오전 11.50.37.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%EC%A0%84%2011.50.37.png)

- 위 사진의 구조는 처리과정을 클래스 단위로 분할하고, 클래스는 컴포넌트 단위로 분리한다. 
  1. 좌측 상단 컴포넌트는 Controller `컨트롤러` 이다. 
  2. 우측 상단 은 Interactor 컴포넌트
  3. 우측 하단은 데이터베이스 컴포넌트
  4. 좌측 하단은 프레젠터, 뷰 를 담당하는 네가지 컴포넌트가 위치 해 있다.
  5. I 로 표시된 클래스는 인터페이스이며, DS로 표시된 클래스는 데이터 구조이다.
     - 화살표가 열려있다면 `사용`관계이며 , 닫혀 있으면 `구현` 또는 `상속` 관계이다. 
- A클래스 -> B클래스 로향하게되면 B클래스는 A클래스를 전혀 호출하지 않는다. 
  -  FinancialDataMapper는 구현 관계를 통 해 FinancialDataGateway를 알고 있지만, FinancialDataGateway는 Financial DataMapper에 대해 아무것도 알지 못한다.
- 모든 컴포넌트는 단방향으로 교차한다. 


![스크린샷 2023-10-23 오전 11.58.48.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%EC%A0%84%2011.58.48.png)
- 여기서의 Interactor는 발생한 모든 곳으로부터 보호받고있으며 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. 
  - Database, Controller, Presenter,View 에서 발생한 어떠한 변경에도 Interactor에 영향을 주지않는다. 
  - 가장 높은 수준의 정책을 포함하기 때문이다.
  - View 보다는 중심적인 문제를 처리해야한다. 
- 아키텍처의 수준에서 OCP가 동작하는 방식은 어떻게,왜,언제,발생 하는지에 따라서 기능을 분리해야한다. 
  - 분리한 기능은 컴포넌트의 계층구조로 조직화 하게 된다면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- 고수준의 컴포넌트는 변경점으로부터 보호받기위해 내부를 은닉해야한다. 


### 결론 
- OCP 는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. 
- OCP 는 시스템을 확장하기 쉽게 만들며 시스템이 너무 많은 영향을 받지 않도록 해야한다.

_시스템은 항상 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어져야한다._

## 리스코프 치환 원칙

_치환의 원칙은 S타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있을때 T타입을 이용한 모든 프로그램에서 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지않는다면 S는 T의 하위 타입이다._


### 정사각형 / 직사각형 문제 
- LSP를 위반하는 전형적인 유명한 문제 정사각형/직사각형 문제를 보자 . 


![스크린샷 2023-10-23 오후 12.10.36.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%ED%9B%84%2012.10.36.png)
- Square 와 Rectangle의 하위 타입으로 적합하지않다. 높이와 너비를 서로 독립적으로 변경될 수 있는 반면, Square는 높이와 너비가 반드시 함께 변경되기 때문이다. 
- LSP 위반을 막기 위한 유일한 방법은 Rectangle이 실제로 Square인지를 검사하는 메커니즘을 User에 적용해야한다.
  - 하지만 이렇게할 경우 사용하는 타입에 의존하게 되므로 결국 타입을 서로 치환할 수 없게됨. 

### 결론
- 리스코프 치환 원칙의 핵심은 상속이다.
- 부모 클래스의 규약을 자식 클래스가 위반하면 안된다. 

_LSP는 아키텍처 수준까지 반드시 확장되게 해야하만 하며, 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 요염되어 상당량의 별도 매커니즘을 추가해야 되기 때문이다._



## 인터페이스 분리 원칙 
- ISP는 사용자가 실제로 사용하는 인터페이스를 사용에 맞게 끔 각기 분리해야하는 설계 원칙이다. 

![스크린샷 2023-10-23 오후 12.35.14.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%ED%9B%84%2012.35.14.png)
- 위 사진에서 User1은 오직 op1을 User2는 op2만을 User3은 op3만을 사용하고있다. 
- OPS가 정적 타입 언어로 작성된 클래스라고 할때 User1은 사용하지 않은 부분들까지 메서드를 의존하게 된다. 
- 이러한 의존성들때문에 op2의 소스 코드가 변경되면 User1도 다시 컴파일한 후 새로 배포해야 한다. 

![스크린샷 2023-10-23 오후 12.39.45.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%ED%9B%84%2012.39.45.png)
- 위처럼 인터페이스 단위로 분리를 하게되면 User1의 소스코드는 U10ps와 op1에는 의존하지만 OPS에는 의존하지 않게된다.
  - 다시 컴파일하고 새로 배포하는 상황은 초래되지 않는다. 

### ISP 와 언어 
- import,use 또는 include는 타입 선언문을 강제하도록 하는데 이때 소스코드 의존성이 발생하고 이로인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
  - 루비나 파이썬은 동적 타입 언어에서는 런타임에 추론이 발생되며 소스 코드 의존성이 아예 없고 , 재컴파일과 재배포가 필요없다. 
- 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하고 결합도가 낮은 시스템을 만들 수 있는 이유 중 하나 가 바로 이때문이다. 

### ISP와 아키텍처 
- ISP를 사용하는 근본적인 동기는 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것이다. 
- 불필요한 재컴파일과 재배포를 강제하기 때문이다.
- 의존하는 기능들이 다른쪽에서 불 필요한 기능들이라해도 영향을 주게 된다. 

### 결론 
_불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다._



## 의존성 역전 원칙
- `유연성이 극대화 된 시스템`은 소스 코드 의존성이 `추상`에 의존하며 `구체`에는 의존하지 않는 시스템이다.
- 정적 타입에서의 use,import,include 구문은 오직 인터페이스나 추상 클래스 같은 부분들에서만 참조해야한다. 구체적인 대상에는 절대로 의존해서는 안 된다.
- 의존하지 않도록 피하고자 하는 것은 `자주 변경될 수밖에 없는 모듈`들 이다.

### 안정된 추상화 
- 추상 인터페이스에 변경이 생기면 구체화한 구현체들도 따라서 수정해야 한다. 
  - 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 대다수의 경우 변경될 필요가 없다. 
  - **따라서 인터페이스는 구현체보다 변동성이 낮다.**
- **_인터페이스의 변동을 낮추기위해 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력해야한다._**
- 큰 구현체보단 안정된 추상 인터페이스의 의존해라. 
  1. 변동성이 큰 구체 클래스를 참조하지 말아야한다. 
     - 추상 인터페이스를 참조하고 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 해야한다. 
  2. 변동성이 큰 구체 클래스로부터 파생하지 말아야 한다. 
     - 상속은 항상 신중하게 사용해야 한다. 
  3. 구체 함수를 오버라이드 하지 말아야 한다. 
     - 추상 함수를 선언해서 구현체들에서부터 각자의 용도에 맞게 구현해야한다. 

### 팩토리 
- 위 규칙들을 준수할려면 구체적인 객체는 특별히 주의해서 생성해야 한다.

![스크린샷 2023-10-23 오후 1.44.03.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%ED%9B%84%201.44.03.png)
- 의존성을 관리하기 위해 추상 팩토리 패턴을 사용한다 
    1. Application 은 ServiceFactory 인터페이스의 makeSvc 메서드를 호출한다. 
    2. 메서드는 ServiceFactory 로부터 파생된 ServiceFactoryImpl 에서 구현된다. 
    3. SerivceFactoryImpl 구현체가 ConcreteImpl 의 인스턴스를 생성한 후 Service 타입으로 변환 
- 그림의 곡선들은 아키텍처 경계를 의미하고 추성적인 것들을 분리한다. 
- 곡선은 시스템을 추상컴포넌트, 구체 컴포넌트로 분리한다. 
    1. 추상컴포넌트는 애플리케이션의 모든 고 수준 업무 규칙을 포함한다.
    2. 구체컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다. 
- 소스 코드 의존성은 정반대 방향으로 곡선을 가로지르는 점 과는 달리, 반대방향으로 역전된다. 
이러한 이유로 이 원칙을 `의존성 역전` 이라 불린다 

### 구체 컴포넌트 
- DIP 위배를 모두 없앨 수는 없다. 
- DIP 를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있다. 
- 시스템의 나머지 부분과는 분리할 수 있다. 
- 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함한다. 
### 결론 
의존성은 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 이러한 규칙은 `의존성 규칙`이라 불린다.
